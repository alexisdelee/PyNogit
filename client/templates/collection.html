<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Collection</title>

    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/csspin-morph.min.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/loader.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/collection.css') }}">
  </head>
  <body>
    <div id="app">
      <table>
        <thead>
          <tr>
            <th colspan="5">Collection's data [ <small><i v-html="collection"></i></small> ]</th>
          </tr>
          <tr>
            <th>#</th>
            <th>Value</th>
            <th colspan="2"></th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="(blob, key) in blobs" :key="blob">
            <td v-html="key"></td>
            <td v-html="blob.value"></td>
            <td>
              <i class="material-icons button edit" @click="edit(blob, key)">edit</i>
              <i class="material-icons button delete" @click="remove(key)">delete</i>
            </td>
            <td>
              <a @click.prevent="setExpire(blob, key)" href="#">
                <img v-if="blob.__expire__ > -1" :title="new Date(blob.__updated_at__ + blob.__expire__ * 1000)" src="{{ url_for('static', filename='img/expiration.png') }}">
                <img v-else src="{{ url_for('static', filename='img/plus.png') }}">
              </a>
            </td>
            <td v-else></td>
          </tr>
        </tbody>
        <tbody>
          <tr class="insertMode">
            <td contenteditable="true" @keydown.enter.prevent="insert">[ key ]</td>
            <td contenteditable="true" @keydown.enter.prevent="insert">[ value ]</td>
            <td>
              <i style="color: #fff !important;" class="material-icons button insert" @click="insert">insert</i>
            </td>
            <td></td>
          </tr>
        </tbody>
        <tfoot>
          <tr>
            <td id="editionMode" v-if="editionMode.enable && !editionMode.insert" :contenteditable="editionMode.enable" colspan="4" @keydown.enter.prevent @keyup.enter="edition" v-html="editionMode.value"></td>
          </tr>
          <tr class="error" v-if="editionMode.error">
            <td colspan="5">Invalid syntax</td>
          </tr>
        </tfoot>
      </table>

      <div v-if="loading" class="loader">
        <div class="cp-spinner cp-morph"></div>
      </div>
    </div>

    <script type="application/javascript" src="{{ url_for('static', filename='js/vuejs.min.js') }}"></script>
    <script type="application/javascript">
      const data = (obj => {
        Object.keys(obj.blobs).forEach(key => {
          obj.blobs[key].__created_at__ = obj.blobs[key].__created_at__ * 1000;
          obj.blobs[key].__updated_at__ = obj.blobs[key].__updated_at__ * 1000;
        });

        return obj;
      })(JSON.parse('{{ data | tojson | safe }}'));
      console.log(data);

      const core = new Vue({
        el: "#app",
        data: {
          collection: data.collection,
          loading: false,
          editionMode: {
            enable: false,
            blob: null,
            key: null,
            value: null,
            error: false,
            isInsertion: false
          },
          blobs: data.blobs
        },
        methods: {
          _put: function(url, body, method = "PUT") {
            this.loading = true;
            return fetch(url, {
              method: method,
              headers: {
                "Accept": "application/json",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(body)
            });
          },
          _delete: function(url, body) {
            return this._put(url, body, "DELETE");
          },
          insert: async function() {
            this.editionMode = {
              enable: false,
              blob: null,
              key: document.querySelector(".insertMode td:first-child").textContent,
              value: document.querySelector(".insertMode td:nth-child(2)").textContent,
              error: false,
              isInsertion: true
            };

            this.editionMode.error = false;
            if (!this.editionMode.key || !this.editionMode.value) {
              return alert("key and value fields are required");
            }

            const data = this.parse(this.editionMode.value);
            if (data === null) {
              return this.editionMode.error = true;
            }

            this.editionMode.value = this.parse(this.editionMode.value).a;

            const response = await this._put("/blobs", {
              collection: this.collection,
              key: this.editionMode.key,
              value: this.editionMode.value
            });

            if (response.status === 200) {
              const data = await response.json();
              if (data.error) {
                this.loading = false;
                return alert(data.error);
              }

              window.location.reload();
            }
          },
          edit: function(blob, key) {
            this.editionMode = {
              enable: true,
              blob: blob,
              key: key,
              value: blob.value,
              error: false,
              isInsertion: false
            };
          },
          parse: function(value) {
            try {
              return JSON.parse("{\"a\": " + value + "}");
            } catch(e) {
              return null;
            }
          },
          edition: function(e) {
            this.editionMode.value = document.querySelector("#editionMode").textContent;
            this.editionMode.error = false;

            const response = this.parse(this.editionMode.value);
            if (response === null) {
              this.editionMode.error = true;
            } else {
              return this.submit();
            }
          },
          submit: async function() {
            // console.log(this.editionMode.key, this.parse(this.editionMode.value).a);
            this.editionMode.blob.value = this.parse(this.editionMode.value).a;

            const response = await this._put("/blobs", {
              collection: this.collection,
              key: this.editionMode.key,
              value: this.editionMode.blob.value
            });

            if (response.status === 200) {
              const data = await response.json();
              if (data.error) {
                this.loading = false;
                return alert(data.error);
              }

              window.location.reload();
            }
          },
          remove: async function(key) {
            const response = await this._delete("/blobs", {
              collection: this.collection,
              key: key
            });

            if (response.status === 200) {
              const data = await response.json();
              if (data.error) {
                this.loading = false;
                return alert(data.error);
              }

              window.location.reload();
            }

            {#this.$delete(this.blobs, key);#}
          },
          setExpire: async function (blob, key) {
            do {
              var seconds = prompt("Set seconds before expiration or -1");
              if (!seconds) {
                return;
              } else if (isNaN(seconds)) {
                continue;
              }

              seconds = parseInt(seconds);
            } while(isNaN(seconds) || (isNaN(seconds) === false && seconds < -1));

            const response = await this._put("/blobs/expire", {
              collection: this.collection,
              key: key,
              seconds: seconds
            });

            if (response.status === 200) {
              const data = await response.json();
              if (data.error) {
                this.loading = false;
                return alert(data.error);
              }

              window.location.reload();
            }
          }
        }
      });
    </script>
  </body>
</html>
